package com.qoomon.banking.swift.message.block;

import com.qoomon.banking.Preconditions;
import com.qoomon.banking.swift.message.block.exception.BlockFieldParseException;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * <b>Basic Header Block</b>
 * <p>
 * <b>Fixed Length Format</b>
 * <pre>
 * 1:  1  - Indicates the Application Id - F = FIN (financial application), A = GPA (general purpose application), L = GPA (for logins, and so on)
 * 2:  2  - Indicates the Service Id -  01 = FIN/GPA, 21 = ACK/NAK
 * 3: 12  - Logical terminal (LT) address, which is typically 8 - BIC, 1 - Logical Terminal Code, 3 - Branch Code
 * 4:  4  - Session number - It is generated by the user's computer and is padded with zeros.
 * 5:  6  - Sequence number - It is generated by the user's computer. It is padded with zeros.
 * </pre>
 * <b>Example</b><br>
 * F01YOURCODEZABC1234567890
 *
 * @see <a href="https://www.ibm.com/support/knowledgecenter/SSBTEG_4.3.0/com.ibm.wbia_adapters.doc/doc/swift/swift72.htm">https://www.ibm.com/support/knowledgecenter/SSBTEG_4.3.0/com.ibm.wbia_adapters.doc/doc/swift/swift72.htm</a>
 */
public class BasicHeaderBlock implements SwiftBlock {

    public static final String BLOCK_ID_1 = "1";

    public static final Pattern BLOCK_CONTENT_PATTERN = Pattern.compile("(.{1})(.{2})(.{12})(.{4})(.{6})");

    private final String applicationId;

    private final String serviceId;

    private final String logicalTerminalAddress;

    private final String sessionNumber;

    private final String sequenceNumber;


    public BasicHeaderBlock(String applicationId, String serviceId, String logicalTerminalAddress, String sessionNumber, String sequenceNumber) {

        Preconditions.checkArgument(applicationId != null, "applicationId can't be null");
        Preconditions.checkArgument(serviceId != null, "serviceId can't be null");
        Preconditions.checkArgument(logicalTerminalAddress != null, "logicalTerminalAddress can't be null");
        Preconditions.checkArgument(sessionNumber != null, "sessionNumber can't be null");
        Preconditions.checkArgument(sequenceNumber != null, "sequenceNumber can't be null");

        this.applicationId = applicationId;
        this.serviceId = serviceId;
        this.logicalTerminalAddress = logicalTerminalAddress;
        this.sessionNumber = sessionNumber;
        this.sequenceNumber = sequenceNumber;
    }

    public static BasicHeaderBlock of(GeneralBlock block) throws BlockFieldParseException {
        Preconditions.checkArgument(block.getId().equals(BLOCK_ID_1), "unexpected block id '%s'", block.getId());

        Matcher blockContentMatcher = BLOCK_CONTENT_PATTERN.matcher(block.getContent());
        if (!blockContentMatcher.matches()) {
            throw new BlockFieldParseException("Block '" + block.getId() + "' content did not match format " + BLOCK_CONTENT_PATTERN);
        }

        String applicationId = blockContentMatcher.group(1);
        String serviceId = blockContentMatcher.group(2);
        String logicalTerminalAddress = blockContentMatcher.group(3);
        String sessionNumber = blockContentMatcher.group(4);
        String sequenceNumber = blockContentMatcher.group(5);

        return new BasicHeaderBlock(applicationId, serviceId, logicalTerminalAddress, sessionNumber, sequenceNumber);
    }

    public String getApplicationId() {
        return applicationId;
    }

    public String getServiceId() {
        return serviceId;
    }

    public String getLogicalTerminalAddress() {
        return logicalTerminalAddress;
    }

    public String getSessionNumber() {
        return sessionNumber;
    }

    public String getSequenceNumber() {
        return sequenceNumber;
    }

    @Override
    public String getId() {
        return BLOCK_ID_1;
    }

    @Override
    public String getContent() {
        return applicationId + serviceId + logicalTerminalAddress + sessionNumber + sequenceNumber;
    }
}
